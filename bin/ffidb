#!/usr/bin/env ruby -W1
# This is free and unencumbered software released into the public domain.

require_relative '../lib/ffidb'

require 'thor' # https://rubygems.org/gems/thor

require 'pathname'
require 'yaml'

class CLI < Thor
  def self.exit_on_failure?; true; end

  class_option :debug, aliases: '-d', type: :boolean, desc: "Enable debugging"
  class_option :verbose, aliases: '-v', type: :boolean, desc: "Be verbose"

  desc "export LIBRARY|SYMBOL...", "Generate C/C++/Java/Python/Ruby/etc code"
  option :format, aliases: '-f', default: nil, desc: "Specify the output format"
  option :exclude, repeatable: true, banner: 'PATTERN', desc: "Exclude symbols matching a glob pattern"
  def export(keyword, *keywords)
    keywords.prepend(keyword)
    format = (self.options[:format] || 'c').to_sym
    excludes = (self.options[:exclude] || []).map do |exclude_pattern|
      FFIDB::Glob.new(exclude_pattern, ignore_case: false, match_substring: false)
    end
    FFIDB::Registry.open do |registry|
      exports = []
      keywords.each do |keyword|
        if library = registry.open_library(keyword)
          library.each_function do |function|
            exports << [library, function] unless excludes.any? { |x| x === function.name }
          end
        else
          matcher = FFIDB::Glob.new(keyword, ignore_case: true, match_substring: false)
          registry.find_functions(matcher) do |function, library|
            exports << [library, function] unless excludes.any? { |x| x === function.name }
          end
        end
      end

      FFIDB::Exporter.for(format).new(**options).emit do |export|
        prev_library = nil
        exports.sort!.uniq.each do |library, function|
          if library != prev_library
            export.finish_library if prev_library
            export.begin_library(library)
            prev_library = library
          end
          export.export_function(function)
        end
        export.finish_library if prev_library
      end
    end
  rescue => error
    raise error if self.options[:debug]
    abort "#{$0}: #{error}"
  end

  desc "init", "Initialize the registry (at: ~/.ffidb)"
  def init
    registry_path = FFIDB::Registry.default_path
    if registry_path.exist?
      warn "#{$0}: The registry at #{registry_path} has already been initialized." if self.options[:verbose]
      return
    end
    git_command = %Q(git clone #{FFIDB::Registry::GIT_HTTPS_URL} #{registry_path})
    system git_command # TODO: improve this
    if $?.exitstatus.nonzero?
      warn "#{$0}: Failed to execute `#{git_command}`: exit code #{$?.exitstatus}."
      exit $?.exitstatus
    end
    Dir.chdir registry_path
  rescue => error
    raise error if self.options[:debug]
    abort "#{$0}: #{error}"
  end

  desc "list [LIBRARY]", "List libraries and functions"
  def list(library_name = nil)
    FFIDB::Registry.open do |registry|
      registry.each_library do |library|
        next if library_name && library_name != library.name
        p library if self.options[:debug]
        library.each_function do |function|
          p function if self.options[:debug]
          print "#{library.name}"
          print self.options[:verbose] ? "@#{library.version}" : '' # TODO: resolve stable symlinks
          print "\t#{function.name}"
          puts self.options[:verbose] ? "\t\t// #{function.definition.to_s}" : '' # TODO: improve formatting
        end
      end
    end
  rescue => error
    raise error if self.options[:debug]
    abort "#{$0}: #{error}"
  end

  desc "parse HEADER...", "Parse .h header files"
  option :config, aliases: '-C', banner: 'FILE', desc: "Use a library.yaml configuration file"
  option :define, aliases: '-D', repeatable: true, banner: 'VAR[=VAL]', desc: "Define a preprocessor symbol"
  option :include, aliases: '-I', repeatable: true, banner: 'DIRECTORY', desc: "Add a directory to the headers search path"
  def parse(path, *paths)
    base_directory = nil
    paths.prepend(path)
    paths = paths.inject([]) do |paths, path|
      path = Pathname(path)
      case
        when !path.exist?
          raise "Path does not exist: #{path}"
        when path.directory?
          base_directory = path if base_directory.nil?
          paths.concat(Dir["#{path}/**/*.h"].sort.map { |p| Pathname(p) })
        else paths << path
      end
    end
    base_directory = paths.first.dirname if base_directory.nil?

    begin
      $VERBOSE = nil # suppress deprecation warnings from ffi-clang
      require 'ffi/clang' # https://rubygems.org/gems/ffi-clang
      $VERBOSE = false
    rescue LoadError => error
      raise error if self.options[:debug]
      abort error.to_s
    end

    FFIDB::Parser.new(base_directory: base_directory, debug: self.options[:verbose] || self.options[:debug]).tap do |parser|
      # Parse a library.yaml configuration file, if given:
      if config_path = self.options[:config]
        config_path = Pathname(config_path)
        raise Errno::ENOENT, config_path.to_s unless config_path.exist?
        config = YAML.load(config_path.read).transform_keys(&:to_sym)
        (config[:configure] || []).each do |var_and_val|
          parser.parse_macro! var_and_val
        end
        (config[:exclude] || []).each do |symbol|
          parser.exclude_symbol! symbol
        end
      end

      # Parse and define all specified -D preprocessor symbols:
      (self.options[:define] || []).each do |var_and_val|
        parser.parse_macro! var_and_val
      end

      # Add all specified -I directories to the headers search path:
      (self.options[:include] || []).each do |dir_path|
        parser.add_include_path! Pathname(dir_path).expand_path
      end

      counter = 0
      paths.each do |path|
        header = parser.parse_header(path) do |exception|
          raise exception if exception.is_a?(FFIDB::ParseError)
          warn "#{$0}: #{exception}"
        end
        header.functions.sort.each do |function|
          puts unless counter.zero?
          counter += 1
          p function if self.options[:debug]
          puts '# ' + function.instance_variable_get(:@debug) if parser.debug
          puts function.to_yaml
        end
      end
    end
  rescue => error
    raise error if self.options[:debug]
    abort "#{$0}: #{error}"
  end

  desc "search KEYWORD", "Search for functions using a glob keyword"
  def search(keyword)
    matcher = FFIDB::Glob.new(keyword, ignore_case: true, match_substring: true)
    p self.options, matcher if self.options[:debug]
    FFIDB::Registry.open do |registry|
      registry.find_functions(matcher) do |function, library|
        puts "#{library.name}\t#{function.name}" # TODO: improve formatting
      end
    end
  rescue => error
    abort "#{$0}: #{error}"
    raise error if self.options[:debug]
  end

  desc "show SYMBOL", "Show function information"
  option :format, aliases: '-f', default: nil, desc: "Specify the output format" # TODO
  def show(function)
    p self.options, function if self.options[:debug]
    FFIDB::Registry.open do |registry|
      found = registry.find_functions(function) do |function, library|
        puts function.to_yaml
        puts
      end
      raise "Function not found: #{function}" unless found
    end
  rescue => error
    raise error if self.options[:debug]
    abort "#{$0}: #{error}"
  end

  desc "update", "Fetch updates to the registry (at: ~/.ffidb)"
  def update
    registry_path = FFIDB::Registry.default_path
    raise "Registry at #{registry_path} not initialized (run `#{$0} init` first?)" unless registry_path.exist?
    Dir.chdir registry_path
    git_command = %Q(git pull)
    system git_command # TODO: improve this
    if $?.exitstatus.nonzero?
      warn "#{$0}: Failed to execute `#{git_command}` in #{registry_path}: exit code #{$?.exitstatus}."
      exit $?.exitstatus
    end
  rescue => error
    raise error if self.options[:debug]
    abort "#{$0}: #{error}"
  end
end # CLI

CLI.start(ARGV)
