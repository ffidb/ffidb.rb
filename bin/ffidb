#!/usr/bin/env ruby -W1
# This is free and unencumbered software released into the public domain.

require_relative '../lib/ffidb'

require 'thor' # https://rubygems.org/gems/thor

require 'pathname'
require 'yaml'

class CLI < Thor
  def self.exit_on_failure?; true; end

  class_option :debug, aliases: '-d', type: :boolean, desc: "Enable debugging"
  class_option :verbose, aliases: '-v', type: :boolean, desc: "Be verbose"

  desc "export LIBRARY|SYMBOL...", "Generate C/C++/Java/Python/Ruby/etc code"
  option :format, aliases: '-f', default: nil, desc: "Specify the output format"
  def export(keyword, *keywords)
    keywords.prepend(keyword)
    format = (self.options[:format] || 'c').to_sym
    FFIDB::Registry.open do |registry|
      FFIDB::Exporter.for(format).new(**options).emit do |export|
        exports = []
        keywords.each do |keyword|
          if library = registry.open_library(keyword)
            library.each_function { |function| exports << [library, function] }
          else
            keyword = Regexp.new('^' + Regexp.escape(keyword).gsub('\*', '.*').gsub('\?', '.') + '$', Regexp::IGNORECASE)
            registry.find_functions(keyword) do |function, library|
              exports << [library, function]
            end
          end
        end
        prev_library = nil
        exports.sort!.uniq.each do |library, function|
          if library != prev_library
            export.finish_library if prev_library
            export.begin_library(library)
            prev_library = library
          end
          export.export_function(function)
        end
        export.finish_library if prev_library
      end
    end
  rescue => error
    raise error if self.options[:debug]
    abort "#{$0}: #{error}"
  end

  desc "init", "Initialize the registry (at: ~/.ffidb)"
  def init
    registry_path = FFIDB::Registry.default_path
    if registry_path.exist?
      warn "#{$0}: The registry at #{registry_path} has already been initialized." if self.options[:verbose]
      return
    end
    git_command = %Q(git clone #{FFIDB::Registry::GIT_HTTPS_URL} #{registry_path})
    system git_command # TODO: improve this
    if $?.exitstatus.nonzero?
      warn "#{$0}: Failed to execute `#{git_command}`: exit code #{$?.exitstatus}."
      exit $?.exitstatus
    end
    Dir.chdir registry_path
  rescue => error
    raise error if self.options[:debug]
    abort "#{$0}: #{error}"
  end

  desc "list [LIBRARY]", "List libraries and functions"
  def list(library_name = nil)
    FFIDB::Registry.open do |registry|
      registry.each_library do |library|
        next if library_name && library_name != library.name
        p library if self.options[:debug]
        library.each_function do |function|
          p function if self.options[:debug]
          print "#{library.name}"
          print self.options[:verbose] ? "@#{library.version}" : '' # TODO: resolve stable symlinks
          print "\t#{function.name}"
          puts self.options[:verbose] ? "\t\t// #{function.definition.to_s}" : '' # TODO: improve formatting
        end
      end
    end
  rescue => error
    raise error if self.options[:debug]
    abort "#{$0}: #{error}"
  end

  desc "parse HEADER...", "Parse .h header files"
  option :define, aliases: '-D', repeatable: true, banner: 'VAR[=VAL]', desc: "Define a preprocessor symbol"
  option :include, aliases: '-I', repeatable: true, banner: 'DIRECTORY', desc: "Add a directory to the headers search path"
  def parse(path, *paths)
    base_directory = nil
    paths.prepend(path)
    paths = paths.inject([]) do |paths, path|
      path = Pathname(path)
      case
        when !path.exist?
          raise "Path does not exist: #{path}"
        when path.directory?
          base_directory = path if base_directory.nil?
          paths.concat(Dir["#{path}/**/*.h"].sort.map { |p| Pathname(p) })
        else paths << path
      end
    end
    base_directory = paths.first.dirname if base_directory.nil?

    begin
      $VERBOSE = nil # suppress deprecation warnings from ffi-clang
      require 'ffi/clang' # https://rubygems.org/gems/ffi-clang
      $VERBOSE = false
    rescue LoadError => error
      raise error if self.options[:debug]
      abort error.to_s
    end

    FFIDB::Parser.new(base_directory: base_directory, debug: self.options[:verbose] || self.options[:debug]).tap do |parser|
      # Parse and define any given preprocessor symbols:
      (self.options[:define] || []).each do |var_and_val|
        var, val = var_and_val.split('=', 2)
        val = 1 if val.nil?
        parser.define! var, val
      end
      (self.options[:include] || []).each do |dir_path|
        parser.add_include_path! Pathname(dir_path).expand_path
      end

      counter = 0
      paths.each do |path|
        header = parser.parse_header(path) do |exception|
          raise exception if exception.is_a?(FFIDB::ParseError)
          warn "#{$0}: #{exception}"
        end
        header.functions.sort.each do |function|
          puts unless counter.zero?
          counter += 1
          p function if self.options[:debug]
          puts '# ' + function.instance_variable_get(:@debug) if parser.debug
          puts function.to_yaml
        end
      end
    end
  rescue => error
    raise error if self.options[:debug]
    abort "#{$0}: #{error}"
  end

  desc "search KEYWORD", "Search for functions using a glob keyword"
  def search(keyword)
    keyword = Regexp.new(Regexp.escape(keyword).gsub('\*', '.*').gsub('\?', '.'), Regexp::IGNORECASE)
    p self.options, keyword if self.options[:debug]
    FFIDB::Registry.open do |registry|
      registry.find_functions(keyword) do |function, library|
        puts "#{library.name}\t#{function.name}" # TODO: improve formatting
      end
    end
  rescue => error
    abort "#{$0}: #{error}"
    raise error if self.options[:debug]
  end

  desc "show SYMBOL", "Show function information"
  option :format, aliases: '-f', default: nil, desc: "Specify the output format" # TODO
  def show(function)
    p self.options, function if self.options[:debug]
    FFIDB::Registry.open do |registry|
      found = registry.find_functions(function) do |function, library|
        puts function.to_yaml
        puts
      end
      raise "Function not found: #{function}" unless found
    end
  rescue => error
    raise error if self.options[:debug]
    abort "#{$0}: #{error}"
  end

  desc "update", "Fetch updates to the registry (at: ~/.ffidb)"
  def update
    registry_path = FFIDB::Registry.default_path
    raise "Registry at #{registry_path} not initialized (run `#{$0} init` first?)" unless registry_path.exist?
    Dir.chdir registry_path
    git_command = %Q(git pull)
    system git_command # TODO: improve this
    if $?.exitstatus.nonzero?
      warn "#{$0}: Failed to execute `#{git_command}` in #{registry_path}: exit code #{$?.exitstatus}."
      exit $?.exitstatus
    end
  rescue => error
    raise error if self.options[:debug]
    abort "#{$0}: #{error}"
  end
end # CLI

CLI.start(ARGV)
