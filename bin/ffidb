#!/usr/bin/env ruby -W0
# This is free and unencumbered software released into the public domain.

require_relative '../lib/ffidb'

require 'thor' # https://rubygems.org/gems/thor

require 'pathname'
require 'yaml'

class CLI < Thor
  def self.exit_on_failure?; true; end

  class_option :debug, aliases: '-d', type: :boolean, desc: "Enable debugging"
  class_option :verbose, aliases: '-v', type: :boolean, desc: "Be verbose"

  desc "export LIBRARY|FUNCTION...", "Export functions as C code"
  option :format, aliases: '-f', default: nil, desc: "Specify the output format"
  def export(*keywords)
    format = (self.options[:format] || 'c').to_sym
    FFIDB::Registry.open do |registry|
      exports = []
      keywords.each do |keyword|
        case library = registry.open_library(keyword)
          when FFIDB::Library
            library.each_function { |function| exports << [library.name, function] }
          else
            keyword = Regexp.new('^' + Regexp.escape(keyword).gsub('\*', '.*').gsub('\?', '.') + '$', Regexp::IGNORECASE)
            registry.find_functions(keyword) do |function, library|
              exports << [library.name, function]
            end
        end
      end
      exports.sort!.uniq.each do |library, function|
        case format
          when :c
            parameters = function.parameters.each_value.inject([]) { |r, p| r << "#{p.type} #{p.name}" }
            puts "#{function.type} #{function.name}(#{parameters.join(', ')});"
        end
      end
    end
  end

  desc "list", "List libraries and functions"
  def list
    FFIDB::Registry.open do |registry|
      registry.each_library do |library|
        p library if self.options[:debug]
        library.each_function do |function|
          p function if self.options[:debug]
          print "#{library.name}"
          print self.options[:verbose] ? "@#{library.version}" : '' # TODO: resolve stable symlinks
          print "\t#{function.name}"
          puts self.options[:verbose] ? "\t\t// #{function.definition.to_s}" : '' # TODO: improve formatting
        end
      end
    end
  end

  desc "parse HEADER...", "Parse .h header files"
  option :define, aliases: '-D', repeatable: true, banner: 'VAR[=VAL]', desc: "Define a preprocessor symbol"
  def parse(*paths)
    base_directory = nil
    paths = paths.inject([]) do |paths, path|
      path = Pathname(path)
      case
        when !path.exist?
          abort "#{$0}: path does not exist: #{path}"
        when path.directory?
          base_directory = path if base_directory.nil?
          paths.concat(Dir["#{path}/**/*.h"].sort.map { |p| Pathname(p) })
        else paths << path
      end
    end
    base_directory = paths.first.dirname if base_directory.nil?

    begin
      require 'ffi/clang' # https://rubygems.org/gems/ffi-clang
    rescue LoadError => error
      p error if self.options[:debug]
      abort error.to_s
    end

    FFIDB::Parser.new(base_directory: base_directory).tap do |parser|
      # Parse and define any given preprocessor symbols:
      (self.options[:define] || []).each do |var_and_val|
        var, val = var_and_val.split('=', 2)
        val = 1 if val.nil?
        parser.define! var, val
      end

      paths.each_with_index do |path, counter|
        header = parser.parse_header(path)
        header.functions.sort.each do |function|
          puts unless counter.zero?
          p function if self.options[:debug]
          counter += 1
          puts "--- !function"
          yaml = {
            'name' => function.name,
            'result' => function.return_type,
          }
          yaml['parameters'] = function.parameters.inject({}) { |h, p| h.merge!(p.to_h) } if function.arity > 0
          yaml['definition'] = {
            'file' => function.definition&.file,
            'line' => function.definition&.line,
          }
          yaml['comment'] = function.comment if function.comment && !function.comment.empty?
          puts YAML.dump(yaml).gsub("---\n", '')
        end
      end
    end
  end

  desc "search KEYWORD", "Search for functions using a glob keyword"
  def search(keyword)
    keyword = Regexp.new(Regexp.escape(keyword).gsub('\*', '.*').gsub('\?', '.'), Regexp::IGNORECASE)
    p self.options, keyword if self.options[:debug]
    FFIDB::Registry.open do |registry|
      registry.find_functions(keyword) do |function, library|
        puts "#{library.name}\t#{function.name}" # TODO: improve formatting
      end
    end
  end

  desc "show FUNCTION", "Show function information"
  option :format, aliases: '-f', default: nil, desc: "Specify the output format" # TODO
  def show(function)
    p self.options, function if self.options[:debug]
    FFIDB::Registry.open do |registry|
      found = registry.find_functions(function) do |function, library|
        puts function.to_yaml
        puts
      end
      abort "#{$0}: function not found: #{function}" unless found
    end
  end
end # CLI

CLI.start(ARGV)
